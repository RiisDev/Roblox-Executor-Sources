#include <Windows.h>
#include <iostream>
#include <string>
#include <cstdint>
#include <vector>
#include <iterator>
#include <sstream>
#include "Retcheck.hpp"
#include "Roblox_Address.h"
using namespace std;
#define ASLRBypass(x) (x - 0x400000 + (DWORD)GetModuleHandleA(0))
#define RBXState RobloxState
#define GetGlobal -10002 // LUA_GLOBALSINDEX
DWORD RBXState;

DWORD RLuaState(DWORD SContext)
{
	return *(DWORD*)(SContext + 228) ^ (SContext + 228);
}

DWORD RSetIdentity(static int Id)
{
	static int Id1 = 116;
	static int Id2 = 24;
	*(DWORD*)(*(DWORD*)(RBXState + Id1) + Id2) = Id;
	return 0;
}


namespace ROffsets
{
	DWORD ScriptContextA = ASLRBypass(Adresses::scriptcontext/*0x020FDF14*/);

	using getfield_def = int(lua_getfield_CCV*)(DWORD a, int b, const char* c);
	getfield_def getfield = (getfield_def)unprotect(ASLRBypass(Adresses::lua_getfield_addr));

	void getglobal(DWORD a, const char* b) // way of accessing getfield.
	{
		getfield(a, GetGlobal, b);
	}

	using setfield_def = int(lua_setfield_CCV*)(DWORD a, int b, const char* c);
	setfield_def setfield = (setfield_def)unprotect(ASLRBypass(Adresses::lua_setfield_addr));

	using pushboolean_def = int(lua_pushboolean_CCV*)(DWORD a, int b); // error = convert int to bool.
	pushboolean_def pushboolean = (pushboolean_def)unprotect(ASLRBypass(Adresses::lua_pushboolean_addr));

	using pushnil_def = int(lua_pushnil_CCV*)(int a);
	pushnil_def pushnil = (pushnil_def)unprotect(ASLRBypass(Adresses::lua_pushnil_addr));

	using pushnumber_def = int(lua_pushnumber_CCV*)(DWORD a, int b);
	pushnumber_def pushnumber = (pushnumber_def)unprotect(ASLRBypass(Adresses::lua_pushnumber_addr));

	using pushstring_def = int(lua_pushstring_CCV*)(DWORD a, const char* b);
	pushstring_def pushstring = (pushstring_def)unprotect(ASLRBypass(Adresses::lua_pushstring_addr));

	using pushvalue_def = int(lua_pushvalue_CCV*)(DWORD, int a2);
	pushvalue_def pushvalue = (pushvalue_def)unprotect(ASLRBypass(Adresses::lua_pushvalue_addr));

	using pcall_def = int(lua_pcall_CCV*)(DWORD a, int b, int c, int d);
	pcall_def pcall = (pcall_def)unprotect(ASLRBypass(Adresses::lua_pcall_addr));

	using settop_def = int(lua_settop_CCV*)(DWORD a, int b);
	settop_def settop = (settop_def)unprotect(ASLRBypass(Adresses::lua_settop_addr));

	using lerror_def = int(lual_error_CCV*)(int a, const char* b, ...);
	lerror_def l_error = (lerror_def)(ASLRBypass(Adresses::lual_error_addr)); // not sure if Lua-l_error or lua_error welp its up to u to fix it
}

namespace Execution
{
	// if you don't know lua c, theres no point of downloading SKID.
	std::vector<std::string> SplitArguments(std::string string)
	{
		std::vector<std::string> elements;
		std::stringstream start(string);
		std::istream_iterator<std::string> begin(start);
		std::istream_iterator<std::string> end;
		std::vector<std::string> vectorStrings(begin, end);
		return vectorStrings;
	}

	void ExecuteLuaC(DWORD RBX, std::string LuaC)
	{
		std::istringstream StringStreamedString(LuaC);
		std::vector<std::string> SplitLines;
		std::string HeldLine;

		while (std::getline(StringStreamedString, HeldLine)) {
			SplitLines.push_back(HeldLine);
			HeldLine = "";
		}

		for (unsigned i = 0; i < SplitLines.size(); i++)
		{
			std::string CurrentLine = SplitLines[i];
			std::vector<std::string> Arg = SplitArguments(CurrentLine);
			if (Arg.at(0) == "pushstring")
			{
				std::string k;
				for (size_t i = 1; i < Arg.size(); i++) {
					if (i < (Arg.size() - 1)) {
						k.append(Arg.at(i) + ' ');
					}
					else if (i == (Arg.size() - 1)) {
						k.append(Arg.at(i));
					}
					else {

					}
				}
				ROffsets::pushstring(RBXState, k.c_str());
			}
			else if (Arg.at(0) == "getfield")
			{
				ROffsets::getfield(RBXState, -1, Arg.at(2).c_str());
			}
			else if (Arg.at(0) == "setfield")
			{
				ROffsets::getfield(RBXState, std::stoi(Arg.at(1)), Arg.at(2).c_str());
			}
			else if (Arg.at(0) == "pushnumber")
			{
				ROffsets::pushnumber(RBXState, std::stoi(Arg.at(1)));
			}
			else if (Arg.at(0) == "pcall")
			{
				ROffsets::pcall(RBXState, std::stoi(Arg[1]), std::stoi(Arg[2]), std::stoi(Arg[3]));
			}
			else if (Arg.at(0) == "getglobal")
			{
				ROffsets::getfield(RBXState, GetGlobal, Arg.at(1).c_str());
			}
			else if (Arg.at(0) == "emptystack")
			{
				ROffsets::settop(RBXState, 0);
			}
			else if (Arg.at(0) == "settop")
			{
				ROffsets::settop(RBXState, std::stoi(Arg.at(1).c_str()));
			}
			else if (Arg.at(0) == "pushboolean")
			{
				//MessageBoxA(0, "Convert int to bool in 2nd pushboolean arguments.", "CommandSploitX", 0); //why speedster uses messagebox, its annoying wtf speedster.
				//ROffsets::pushboolean(RBXState, Arg.at(1).c_str());

				//Don't DM me for adding this some stupid code // 
				ROffsets::getfield(RBXState, -10002, "warn");
				ROffsets::pushstring(RBXState, "Convert int to bool in 2nd pushboolean arguments.");
				ROffsets::pcall(RBXState, 1, 0, 0);
			}
			else if (Arg.at(0) == "pushvalue")
			{
				ROffsets::pushvalue(RBXState, std::stoi(Arg.at(1)));
			}
			else // doesn't match any of the text above.
			{
				ROffsets::getfield(RBXState, -10002, "warn");
				ROffsets::pushstring(RBXState, "Unknown global execution. - Ur Mom Unknown global");
				ROffsets::pcall(RBXState, 1, 0, 0);
			}
		}
	}
}

namespace Scanner
{
	bool Compare(const BYTE* location, const BYTE* aob, const char* mask) {
		for (; *mask; ++aob, ++mask, ++location) {
			__try {
				if (*mask == 'x' && *location != *aob)
					return 0;
			}
			__except (1) {
				return 0;
			}
		}
		return 1;
	}

	DWORD Find_Pattern(BYTE* pattern, char* mask, BYTE protection = (PAGE_READONLY | PAGE_READWRITE | PAGE_WRITECOPY | PAGE_EXECUTE | PAGE_EXECUTE_READ | PAGE_EXECUTE_READWRITE | PAGE_EXECUTE_WRITECOPY)) {
		SYSTEM_INFO SI = { 0 };
		GetSystemInfo(&SI);
		DWORD start = (DWORD)SI.lpMinimumApplicationAddress;
		DWORD end = (DWORD)SI.lpMaximumApplicationAddress;
		MEMORY_BASIC_INFORMATION mbi;
		while (start < end && VirtualQuery((void*)start, &mbi, sizeof(mbi))) {
			if ((mbi.State & MEM_COMMIT) && (mbi.Protect & protection) && !(mbi.Protect & PAGE_GUARD)) {
				for (DWORD i = (DWORD)mbi.BaseAddress; i < (DWORD)mbi.BaseAddress + mbi.RegionSize; ++i) {
					if (Compare((BYTE*)i, pattern, mask)) {
						return i;
					}
				}
			}
			start += mbi.RegionSize;
		}
		return 0;
	}

	static int Scan(DWORD mode, char* content, char* mask) {
		return Find_Pattern((BYTE*)content, mask, mode);
	}
}
